(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{226:function(t,e,s){"use strict";s.r(e);var a=s(0),r=Object(a.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("React 性能优化是哪个周期函数？")]),t._v(" "),s("p",[t._v("shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 DOM。因为 DOM 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 DOM diff 算法，可以极大的提高性能。")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://segmentfault.com/a/1190000006254212",target:"_blank",rel:"noopener noreferrer"}},[t._v("React 性能优化"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("为什么 Virtual DOM 会提高性能？")]),t._v(" "),s("p",[t._v("虚拟 DOM 相当于在 JavaScript 和 真实 DOM 中间加了一个缓存，利用 DOM diff 算法避免了没有必要的 DOM 操作，从而提高性能。")]),t._v(" "),s("p",[t._v("具体实现步骤如下：")]),t._v(" "),s("p",[t._v("用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中。当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异。把所记录的差异应用到步骤步骤一所构建的真正的 DOM 树上，视图就更新了。")]),t._v(" "),s("p",[t._v("React 性能优化方案？")]),t._v(" "),s("ul",[s("li",[t._v("重写 shouldComponentUpdate 来避免不必要的 DOM 操作")]),t._v(" "),s("li",[t._v("使用 Production 版本的 React.js")]),t._v(" "),s("li",[t._v("使用 key 来帮助 React 识别列表中所有子组件的最小变化")])]),t._v(" "),s("p",[t._v("https://segmentfault.com/a/1190000015366521")]),t._v(" "),s("h3",{attrs:{id:"不要在-render-的函数中绑定值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不要在-render-的函数中绑定值","aria-hidden":"true"}},[t._v("#")]),t._v(" 不要在 render 的函数中绑定值")]),t._v(" "),s("p",[t._v("假设你有一个项目列表，每个项目都传递一个唯一的参数到父方法。为了绑定参数，你可能会这么做：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("<CommentItem likeComment={() => this.likeComment(user.id)} />\n")])])]),s("p",[t._v("这个问题会导致每次父组件 render 方法被调用时，一个新的函数被创建，已将其传入"),s("code",[t._v("likeComment")]),t._v("。这会有一个改变每个子组件"),s("code",[t._v("props")]),t._v("的副作用，它将会造成他们全部重新渲染，即使数据本身没有发生变化。")]),t._v(" "),s("p",[t._v("为了解决这个问题，只需要将父组件的原型方法的引用传递给子组件。子组件的"),s("code",[t._v("likeComment")]),t._v("属性将总是有相同的引用，这样就不会造成不必要的重新渲染。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("<CommentItem likeComment={this.likeComment} userID={user.id} />\n")])])]),s("p",[t._v("然后再子组件中创建一个引用了传入属性的类方法：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class CommentItem extends PureComponent {\n  ...\n  handleLike() {\n    this.props.likeComment(this.props.userID)\n  }\n  ...\n}\n")])])]),s("h3",{attrs:{id:"不要在-render-方法里派生数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不要在-render-方法里派生数据","aria-hidden":"true"}},[t._v("#")]),t._v(" 不要在 render 方法里派生数据")]),t._v(" "),s("p",[t._v("考虑一下你的配置组件将从一系列文章中展示用户最喜欢的十篇文章。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("render() {\n  const { posts } = this.props\n  const topTen = posts.sort((a, b) => b.likes - a.likes).slice(0, 9)\n  return //...\n}\n")])])]),s("p",[t._v("每次组件重新渲染时"),s("code",[t._v("topTen")]),t._v("都将有一个新的引用，即使"),s("code",[t._v("posts")]),t._v("没有改变并且派生数据也是相同的。这将造成列表不必要的重新渲染。")]),t._v(" "),s("p",[t._v("你可以通过缓存你的派生数据来解决这个问题。例如，设置派生数据在你的组件"),s("code",[t._v("state")]),t._v("中，仅当 posts 更新时它才更新。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("componentWillMount() {\n  this.setTopTenPosts(this.props.posts)\n}\ncomponentWillReceiveProps(nextProps) {\n  if (this.props.posts !== nextProps.posts) {\n    this.setTopTenPosts(nextProps)\n  }\n}\nsetTopTenPosts(posts) {\n  this.setState({\n    topTen: posts.sort((a, b) => b.likes - a.likes).slice(0, 9)\n  })\n}\n")])])]),s("p",[t._v("如果你正在使用 Redux，可以考虑使用"),s("a",{attrs:{href:"https://github.com/reduxjs/reselect",target:"_blank",rel:"noopener noreferrer"}},[t._v("reselect"),s("OutboundLink")],1),t._v('来创建"selectors"来组合和缓存派生数据。')]),t._v(" "),s("hr"),t._v(" "),s("h2",{attrs:{id:"code-splitting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#code-splitting","aria-hidden":"true"}},[t._v("#")]),t._v(" Code Splitting")]),t._v(" "),s("h2",{attrs:{id:"shouldcomponentupdate-避免重复渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate-避免重复渲染","aria-hidden":"true"}},[t._v("#")]),t._v(" shouldComponentUpdate 避免重复渲染")]),t._v(" "),s("h2",{attrs:{id:"使用不可突变数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用不可突变数据结构","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用不可突变数据结构")]),t._v(" "),s("h2",{attrs:{id:"组件尽可能拆分解耦"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件尽可能拆分解耦","aria-hidden":"true"}},[t._v("#")]),t._v(" 组件尽可能拆分解耦")]),t._v(" "),s("p",[t._v("组件尽可能的细分，比如一个 Input + List 组件，可以将 List 分成一个 PureComponent，只在 List 数据变化时更新。否则在 Input 值变化页面重新渲染的时候，List 也需要进行不必要的 DOM Diff。")]),t._v(" "),s("h2",{attrs:{id:"列表类组件优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列表类组件优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 列表类组件优化")]),t._v(" "),s("h2",{attrs:{id:"bind-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bind-函数","aria-hidden":"true"}},[t._v("#")]),t._v(" bind 函数")]),t._v(" "),s("h2",{attrs:{id:"不要滥用-props"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不要滥用-props","aria-hidden":"true"}},[t._v("#")]),t._v(" 不要滥用 Props")]),t._v(" "),s("h2",{attrs:{id:"reactdomserver-进行服务端渲染组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reactdomserver-进行服务端渲染组件","aria-hidden":"true"}},[t._v("#")]),t._v(" ReactDOMServer 进行服务端渲染组件")]),t._v(" "),s("h2",{attrs:{id:"react-性能检测工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-性能检测工具","aria-hidden":"true"}},[t._v("#")]),t._v(" React 性能检测工具")]),t._v(" "),s("p",[t._v("https://zhuanlan.zhihu.com/p/64892855")])])},[],!1,null,null,null);e.default=r.exports}}]);