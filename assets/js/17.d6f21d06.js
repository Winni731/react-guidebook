(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{257:function(e,t,r){"use strict";r.r(t);var a=r(0),n=Object(a.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"reactdom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reactdom","aria-hidden":"true"}},[e._v("#")]),e._v(" ReactDOM")]),e._v(" "),r("p",[e._v("React 的声明式渲染机制把复杂的 DOM 操作抽象为简单的 State 和 Props 的操作，因此避免了很多直接的 DOM 操作。不过，仍然有一些 DOM 操作是 React 无法避免或者正在努力避免的。")]),e._v(" "),r("h2",{attrs:{id:"官方文档"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#官方文档","aria-hidden":"true"}},[e._v("#")]),e._v(" 官方文档")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://reactjs.org/docs/react-dom.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ReactDOM"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://reactjs.org/docs/react-dom-server.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ReactDOMServer"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://reactjs.org/docs/dom-elements.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("DOM Elements"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"reactdom-api"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reactdom-api","aria-hidden":"true"}},[e._v("#")]),e._v(" ReactDOM API")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("ReactDOM.render(element, container [, callback])")]),e._v(" 顶层组件用于将 VirtualDOM 渲染到浏览器的 DOM 中")]),e._v(" "),r("li",[r("code",[e._v("ReactDOM.findDOMNode(component)")]),e._v(" 获取当前组件的 DOM 元素节点引用")]),e._v(" "),r("li",[r("code",[e._v("ReactDOM.unmountComponentAtNode(container)")]),e._v(" 从 DOM 树中卸载已装载的 React 组件并清空事件监听和状态。")]),e._v(" "),r("li",[e._v("hydrate")]),e._v(" "),r("li",[r("code",[e._v("ReactDOM.createPortal(child, container)")])])]),e._v(" "),r("h2",{attrs:{id:"render"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#render","aria-hidden":"true"}},[e._v("#")]),e._v(" render")]),e._v(" "),r("ul",[r("li",[e._v("控制你传进来的容器节点里的内容。第一次被调用时，内部所有已经存在的 DOM 元素都会被替换掉。之后的调用会使用 React 的 DOM 比较算法进行高效的更新。")]),e._v(" "),r("li",[e._v("不会修改容器节点（只修改容器的子项）。你可以在不覆盖已有子节点的情况下添加一个组件到已有的 DOM 节点中去。")]),e._v(" "),r("li",[e._v("目前会返回一个引用，指向 ReactComponent 的根实例。但是这个返回值是历史遗留，应该避免使用。因为未来版本的 React 可能会在某些情况下进行异步渲染。如果你真的需要一个指向 ReactComponent 的根实例的引用，推荐的方法是天假一个 "),r("code",[e._v("callback")]),e._v(" 到根元素上。")])])])},[],!1,null,null,null);t.default=n.exports}}]);