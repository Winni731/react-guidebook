(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{227:function(v,_,e){"use strict";e.r(_);var o=e(0),t=Object(o.a)({},function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("Hook 是一种复用状态逻辑的方式")]),v._v(" "),e("p",[e("strong",[v._v("在组件之间复用状态逻辑很难")])]),v._v(" "),e("p",[v._v("React 没有提供将可复用性行为附加到组件的途径")]),v._v(" "),e("p",[v._v("解决这类问题的现行方案是使用 render props 和高阶组件")]),v._v(" "),e("p",[v._v("但是这类解决方案需要重新组织你的组件结构，providers、consumers、高阶组件和 render props 等其他抽象层组成的组件会形成嵌套地狱。")]),v._v(" "),e("p",[v._v("React 需要为共享状态逻辑提供更好的原生途径。")]),v._v(" "),e("p",[v._v("使用 Hook 可从组件中提取状态逻辑，使得这些逻辑可单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。")]),v._v(" "),e("p",[e("strong",[v._v("复杂组件变得难以理解")])]),v._v(" "),e("p",[v._v("维护的组件充斥副作用，每个生命周期中包含一些不相关的逻辑，例如获取数据、事件监听等。它们相互关联且需要对照修改的代码进行拆分，而完全不相关的代码却在同一个方法中组合起来。容易产生 Bug，并且导致逻辑不一致。")]),v._v(" "),e("p",[v._v("不能拆分更小的粒度，因为状态逻辑无处不在，给测试带来一些挑战。这也是很多应用引入状态管理库的原因，但这同时也会带来很多抽象的概念，需要在不同文件间切换，使得复用变得更难。")]),v._v(" "),e("p",[v._v("Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而非强制按照生命周期划分。还可以使用 reducer 来管理组件的内部状态，使其更加可预测。")]),v._v(" "),e("p",[e("strong",[v._v("难以理解的 Class")])]),v._v(" "),e("p",[v._v("Class 是学习 React 的一大屏障，需要理解 this 的工作方式，不能忘记绑定事件处理器，没有稳定的语法提案，这些代码非常荣誉。")]),v._v(" "),e("p",[v._v("class 组件会无意中鼓励开发者使用一些让优化措施无效的方案。也给目前工具带来问题，例如 class 不能很好地压缩，并且会使热重载出现不稳定的情况。")]),v._v(" "),e("p",[v._v("Hook 使你在非 class 情况下使用更多的 React 特性。")]),v._v(" "),e("p",[v._v("概念上，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。")]),v._v(" "),e("p",[v._v("StateHook")]),v._v(" "),e("p",[v._v("EffectHook")]),v._v(" "),e("p",[v._v("自定义 Hook")]),v._v(" "),e("p",[v._v("useState")]),v._v(" "),e("p",[v._v("useEffect")]),v._v(" "),e("p",[v._v("useContext")]),v._v(" "),e("p",[v._v("useReducer")])])},[],!1,null,null,null);_.default=t.exports}}]);