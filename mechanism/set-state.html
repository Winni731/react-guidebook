<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>setState | React-Guidebook</title>
    <meta name="description" content="">
    <link rel="icon" href="favicon.ico">
    
    <link rel="preload" href="/react-guidebook/assets/css/0.styles.e28a9572.css" as="style"><link rel="preload" href="/react-guidebook/assets/js/app.260c1e95.js" as="script"><link rel="preload" href="/react-guidebook/assets/js/2.faf5b053.js" as="script"><link rel="preload" href="/react-guidebook/assets/js/12.96017118.js" as="script"><link rel="prefetch" href="/react-guidebook/assets/js/10.12b8a1f6.js"><link rel="prefetch" href="/react-guidebook/assets/js/11.08027518.js"><link rel="prefetch" href="/react-guidebook/assets/js/13.843c2301.js"><link rel="prefetch" href="/react-guidebook/assets/js/14.350d4ea6.js"><link rel="prefetch" href="/react-guidebook/assets/js/15.922c628d.js"><link rel="prefetch" href="/react-guidebook/assets/js/16.179de27c.js"><link rel="prefetch" href="/react-guidebook/assets/js/17.d6f21d06.js"><link rel="prefetch" href="/react-guidebook/assets/js/18.3b94c7d4.js"><link rel="prefetch" href="/react-guidebook/assets/js/19.9d272f30.js"><link rel="prefetch" href="/react-guidebook/assets/js/20.5719f794.js"><link rel="prefetch" href="/react-guidebook/assets/js/21.32a481df.js"><link rel="prefetch" href="/react-guidebook/assets/js/22.a8130aca.js"><link rel="prefetch" href="/react-guidebook/assets/js/23.04c27a3a.js"><link rel="prefetch" href="/react-guidebook/assets/js/24.bc3baace.js"><link rel="prefetch" href="/react-guidebook/assets/js/25.e2bf72b2.js"><link rel="prefetch" href="/react-guidebook/assets/js/26.e2f5f647.js"><link rel="prefetch" href="/react-guidebook/assets/js/27.12c8dd66.js"><link rel="prefetch" href="/react-guidebook/assets/js/28.786c50e6.js"><link rel="prefetch" href="/react-guidebook/assets/js/29.bdb196e1.js"><link rel="prefetch" href="/react-guidebook/assets/js/3.28696f6a.js"><link rel="prefetch" href="/react-guidebook/assets/js/30.cf0e07b4.js"><link rel="prefetch" href="/react-guidebook/assets/js/31.6dad3ae2.js"><link rel="prefetch" href="/react-guidebook/assets/js/32.bd3b8924.js"><link rel="prefetch" href="/react-guidebook/assets/js/33.c7028e61.js"><link rel="prefetch" href="/react-guidebook/assets/js/34.980dc58f.js"><link rel="prefetch" href="/react-guidebook/assets/js/35.b7595861.js"><link rel="prefetch" href="/react-guidebook/assets/js/36.5096dad5.js"><link rel="prefetch" href="/react-guidebook/assets/js/37.95547070.js"><link rel="prefetch" href="/react-guidebook/assets/js/38.158db71c.js"><link rel="prefetch" href="/react-guidebook/assets/js/39.533eee82.js"><link rel="prefetch" href="/react-guidebook/assets/js/4.63e5ba6d.js"><link rel="prefetch" href="/react-guidebook/assets/js/40.58cb3743.js"><link rel="prefetch" href="/react-guidebook/assets/js/41.d5b5333a.js"><link rel="prefetch" href="/react-guidebook/assets/js/42.8fd16888.js"><link rel="prefetch" href="/react-guidebook/assets/js/43.17e7ea62.js"><link rel="prefetch" href="/react-guidebook/assets/js/44.c75d55fd.js"><link rel="prefetch" href="/react-guidebook/assets/js/45.cfb8cfbd.js"><link rel="prefetch" href="/react-guidebook/assets/js/46.21fefad7.js"><link rel="prefetch" href="/react-guidebook/assets/js/47.65560a73.js"><link rel="prefetch" href="/react-guidebook/assets/js/48.b09b6aff.js"><link rel="prefetch" href="/react-guidebook/assets/js/49.17f999ca.js"><link rel="prefetch" href="/react-guidebook/assets/js/5.dd0f972b.js"><link rel="prefetch" href="/react-guidebook/assets/js/50.3c7b255a.js"><link rel="prefetch" href="/react-guidebook/assets/js/51.f1ffef2a.js"><link rel="prefetch" href="/react-guidebook/assets/js/52.8414d27e.js"><link rel="prefetch" href="/react-guidebook/assets/js/53.ee10be58.js"><link rel="prefetch" href="/react-guidebook/assets/js/54.790296ee.js"><link rel="prefetch" href="/react-guidebook/assets/js/55.b3491420.js"><link rel="prefetch" href="/react-guidebook/assets/js/56.ded674be.js"><link rel="prefetch" href="/react-guidebook/assets/js/57.f989e8b0.js"><link rel="prefetch" href="/react-guidebook/assets/js/58.2cc1c592.js"><link rel="prefetch" href="/react-guidebook/assets/js/6.38cc656d.js"><link rel="prefetch" href="/react-guidebook/assets/js/7.86641c97.js"><link rel="prefetch" href="/react-guidebook/assets/js/8.8391da58.js"><link rel="prefetch" href="/react-guidebook/assets/js/9.a3a45a50.js">
    <link rel="stylesheet" href="/react-guidebook/assets/css/0.styles.e28a9572.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/react-guidebook/" class="home-link router-link-active"><img src="/react-guidebook/favicon.png" alt="React-Guidebook" class="logo"> <span class="site-name can-hide">React-Guidebook</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/tsejx/React-Guidebook" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/tsejx/React-Guidebook" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>基本概念</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-guidebook/concept/react.html" class="sidebar-link">React 特性</a></li><li><a href="/react-guidebook/concept/jsx.html" class="sidebar-link">JSX 语法</a></li><li><a href="/react-guidebook/concept/props.html" class="sidebar-link">Props</a></li><li><a href="/react-guidebook/concept/state.html" class="sidebar-link">State</a></li><li><a href="/react-guidebook/concept/lifecycle.html" class="sidebar-link">生命周期</a></li><li><a href="/react-guidebook/concept/component.html" class="sidebar-link">组件化</a></li><li><a href="/react-guidebook/concept/react-dom.html" class="sidebar-link">ReactDOM</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>核心架构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-guidebook/core/fiber.html" class="sidebar-link">Fiber</a></li><li><a href="/react-guidebook/core/virtual-dom.html" class="sidebar-link">Virtual DOM</a></li><li><a href="/react-guidebook/core/diffing-algorithm.html" class="sidebar-link">差异化算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>运行机制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-guidebook/mechanism/set-state.html" class="active sidebar-link">setState</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#基本语法" class="sidebar-link">基本语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#updater-参数" class="sidebar-link">updater 参数</a></li><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#callback-参数" class="sidebar-link">callback 参数</a></li></ul></li><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#基本特性" class="sidebar-link">基本特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#状态不能直接修改" class="sidebar-link">状态不能直接修改</a></li><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#异步与同步" class="sidebar-link">异步与同步</a></li><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#批量更新" class="sidebar-link">批量更新</a></li></ul></li><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#最佳实践" class="sidebar-link">最佳实践</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#相同周期多次调用" class="sidebar-link">相同周期多次调用</a></li><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#同步更新策略" class="sidebar-link">同步更新策略</a></li><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#浏览器监听事件" class="sidebar-link">浏览器监听事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#实现流程" class="sidebar-link">实现流程</a></li><li class="sidebar-sub-header"><a href="/react-guidebook/mechanism/set-state.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/react-guidebook/mechanism/render.html" class="sidebar-link">渲染策略</a></li><li><a href="/react-guidebook/mechanism/refs.html" class="sidebar-link">Refs</a></li><li><a href="/react-guidebook/mechanism/portals.html" class="sidebar-link">Portals</a></li><li><a href="/react-guidebook/mechanism/context.html" class="sidebar-link">Context</a></li><li><a href="/react-guidebook/mechanism/render-props.html" class="sidebar-link">Render Props</a></li><li><a href="/react-guidebook/mechanism/high-order-component.html" class="sidebar-link">高阶组件</a></li><li><a href="/react-guidebook/mechanism/handling-events.html" class="sidebar-link">事件处理</a></li><li><a href="/react-guidebook/mechanism/synthetic-event.html" class="sidebar-link">合成事件</a></li><li><a href="/react-guidebook/mechanism/hooks.html" class="sidebar-link">Hooks</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>功能扩展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-guidebook/feature/memo.html" class="sidebar-link">React.memo</a></li><li><a href="/react-guidebook/feature/pure-component.html" class="sidebar-link">React.PureComponent</a></li><li><a href="/react-guidebook/feature/fragment.html" class="sidebar-link">React.Fragment</a></li><li><a href="/react-guidebook/feature/create-ref.html" class="sidebar-link">React.createRef</a></li><li><a href="/react-guidebook/feature/forward-ref.html" class="sidebar-link">React.forwardRef</a></li><li><a href="/react-guidebook/feature/lazy.html" class="sidebar-link">React.lazy</a></li><li><a href="/react-guidebook/feature/suspense.html" class="sidebar-link">React.Suspense</a></li><li><a href="/react-guidebook/feature/clone-element.html" class="sidebar-link">React.cloneElement</a></li><li><a href="/react-guidebook/feature/is-valid-element.html" class="sidebar-link">React.isValidElement</a></li><li><a href="/react-guidebook/feature/children.html" class="sidebar-link">React.Children</a></li><li><a href="/react-guidebook/feature/force-update.html" class="sidebar-link">forceUpdate</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>生态</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>路由管理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-guidebook/ecosystem/routing/spa-routing.html" class="sidebar-link">单页面应用路由机制</a></li><li><a href="/react-guidebook/ecosystem/routing/react-router.html" class="sidebar-link">React Router</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据管理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-guidebook/ecosystem/redux/flux.html" class="sidebar-link">Flux</a></li><li><a href="/react-guidebook/ecosystem/redux/redux.html" class="sidebar-link">Redux</a></li><li><a href="/react-guidebook/ecosystem/redux/react-redux.html" class="sidebar-link">React Redux</a></li><li><a href="/react-guidebook/ecosystem/redux/redux-saga.html" class="sidebar-link">Redux Saga</a></li><li><a href="/react-guidebook/ecosystem/redux/redux-thunk.html" class="sidebar-link">Redux Thunk</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>类型检测</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react-guidebook/ecosystem/type/prop-types.html" class="sidebar-link">PropTypes</a></li></ul></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="setstate"><a href="#setstate" aria-hidden="true" class="header-anchor">#</a> setState</h1> <blockquote><p><code>setState()</code> enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.</p> <p><code>setState()</code> 将需要处理的变化塞入（译者注：setState 源码中将一个需要改变的变化存放到组件的 state 对象中，采用队列处理）组件的 state 对象中， 并告诉该组件及其子组件需要用更新的状态来重新渲染。这是用于响应事件处理和服务端响应的更新用户界面的主要方式。</p></blockquote> <p>官方文档关于 <code>setState</code> 的描述部分：<a href="https://reactjs.org/docs/react-component.html#setstate" target="_blank" rel="noopener noreferrer">英文文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="http://react.yubolun.com/docs/react-component.html#setstate" target="_blank" rel="noopener noreferrer">中文文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>为了提高框架性能，React 将 <code>setState</code> 设置为<strong>状态批量处理或推迟更新</strong>，实际上就是<strong>异步操作函数</strong>，该方法不会以顺序控制流的方式处理相同周期内的事件，同时，我们也不能依赖 <code>this.state</code> 用于计算未来状态。</p> <h2 id="基本语法"><a href="#基本语法" aria-hidden="true" class="header-anchor">#</a> 基本语法</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>updater <span class="token punctuation">[</span><span class="token punctuation">,</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><table><thead><tr><th>参数</th> <th>说明</th> <th>类型</th></tr></thead> <tbody><tr><td>updater</td> <td>更新器</td> <td>object | function</td></tr> <tr><td>callback</td> <td>回调函数</td> <td>function</td></tr></tbody></table> <h3 id="updater-参数"><a href="#updater-参数" aria-hidden="true" class="header-anchor">#</a> updater 参数</h3> <h4 id="函数形式"><a href="#函数形式" aria-hidden="true" class="header-anchor">#</a> 函数形式</h4> <p><code>updater</code> 参数可为一个带签名的函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevState<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> stateChange<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><table><thead><tr><th>stateChange 参数</th> <th>说明</th> <th>类型</th></tr></thead> <tbody><tr><td>prevState</td> <td>未更新前状态的引用。该引用不应该被直接改变。</td> <td>obj</td></tr> <tr><td>props</td> <td>父组件传入的属性</td> <td>obj</td></tr></tbody></table> <p><code>updater</code> 函数接收到的 <code>prevState</code>  和  <code>props</code> 保证都是最新的。</p> <p>该函数通过对 <code>prevState</code> 或 <code>props</code> 的引用构建一个新对象作为输出，该输出后续用于与旧状态（prevState）浅合并。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Example</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevState<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    index<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>index <span class="token operator">+</span> props<span class="token punctuation">.</span>step<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="对象形式"><a href="#对象形式" aria-hidden="true" class="header-anchor">#</a> 对象形式</h4> <p><code>updater</code> 参数亦可为对象类型，该对象仅会浅合并到新状态中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>obj stateChange<span class="token punctuation">,</span> <span class="token punctuation">[</span>callback<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>与函数形式相类似，对象形式的 <code>updater</code> 参数通过直接构建与旧状态浅合并的新对象作为输出。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Example</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  index<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="callback-参数"><a href="#callback-参数" aria-hidden="true" class="header-anchor">#</a> callback 参数</h3> <p><code>callback</code> 参数为可选的回调函数，该函数会在<strong>状态更新完成同时组件被重新渲染之后</strong>执行。通常，对于此类逻辑，官方推荐使用 <code>componentDidUpdate</code> 生命周期函数。</p> <h2 id="基本特性"><a href="#基本特性" aria-hidden="true" class="header-anchor">#</a> 基本特性</h2> <p>在了解 <code>setState</code> 之前，我们先来简单了解 React 包装结构：<strong>Transaction</strong></p> <p>事务（Transaction）是 React 中的一个调用结构，用于包装一个方法，结构为：<code>initialize - performance(method) - close</code>。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作；</p> <p><img src="/react-guidebook/assets/img/transaction-simplicity.b844fb71.jpg" alt="transaction-simplicity"></p> <h3 id="状态不能直接修改"><a href="#状态不能直接修改" aria-hidden="true" class="header-anchor">#</a> 状态不能直接修改</h3> <p>❓<strong>为什么不同直接通过 <code>this.state</code> 直接修改状态？</strong></p> <p>在实际开发中，直接修改状态中的值，虽然事实上改变了组件的内部状态，但是却没有驱动组件进行重新渲染，既然组件没有重新渲染，用户界面中 <code>this.state</code> 值对应显示部分也就不会有变化。而 <code>this.setState()</code> 函数所处理的事务，首先是改变 <code>this.setState</code> 的值，然后驱动组件经历更新过程，这样用户界面上相应的 <code>this.state</code> 值才有相应的变化。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Error</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'React'</span><span class="token punctuation">;</span>

<span class="token comment">// Correct</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">'React'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="异步与同步"><a href="#异步与同步" aria-hidden="true" class="header-anchor">#</a> 异步与同步</h3> <p><code>setState</code> 并不是单纯的异步或同步，这其实与调用时的环境相关。</p> <h4 id="合成事件和生命周期函数"><a href="#合成事件和生命周期函数" aria-hidden="true" class="header-anchor">#</a> 合成事件和生命周期函数</h4> <p>在<strong>合成事件</strong>和<strong>生命周期函数</strong>（除 <code>componentDidUpdate</code> ）中，<code>setState</code> 是异步的。</p> <p><strong>原因</strong>：因为在 <code>setState</code> 的实现中，有一个判断：当更新策略正在<strong>事务流</strong>的执行中时，该组件更新会被推入 <code>dirtyComponents</code> 队列中等待执行；否则，开始执行 <code>batchedUpdates</code> 队列更新。</p> <ul><li>在生命周期函数调用中，更新策略都处于更新之前，组件仍处于事务流中，而 <code>componentDidUpdate</code> 是在更新之后，此时组件已经不在事务流中，因此则会同步执行</li> <li>在合成事件中，React 是基于事务流完成的事件委托机制实现，也是处于事务流中；</li></ul> <p><strong>问题</strong>：无法在 <code>setState</code> 后马上从 <code>this.state</code> 上获取更新后的值。</p> <p><strong>解决</strong>：如果需要马上同步并获取最新值，可通过 <code>setState((prevState, props) =&gt; {}, callback)</code> 获取最新的状态。</p> <h4 id="原生事件和定时器"><a href="#原生事件和定时器" aria-hidden="true" class="header-anchor">#</a> 原生事件和定时器</h4> <p>在<strong>原生事件</strong>和 <strong>setTimeout</strong> 中，<code>setState</code> 是同步的，可以马上获取更新后的值。</p> <p><strong>原因</strong>：原生事件是浏览器本身的实现，与事务流无关，自然是同步的；而 <code>setTimeout</code> 是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步。</p> <p>❓ <strong>为什么 React 处理 setState 要实行异步更新机制？</strong></p> <p>由于 <code>setState</code> 会触发组件的更新渲染，也就会运行组件的 diff 算法。如果每次 <code>setState</code> 都要运行这套流程，将会十分消耗性能，并且完全没有必要。</p> <p><strong>总结 <code>state</code> 实现异步更新的理由</strong>：</p> <ul><li>React 运行机制的性能考虑</li> <li>这将破坏 <code>props</code> 和 <code>state</code> 之间的一致性，引起问题，非常难以调试</li> <li>这将使一些 React 新特性不能实现</li></ul> <p>深入研究请查阅：📖 <a href="/react-guidebook/mechanism/setState.html">setState</a></p> <h3 id="批量更新"><a href="#批量更新" aria-hidden="true" class="header-anchor">#</a> 批量更新</h3> <p>在<strong>合成事件</strong>和<strong>生命周期函数</strong>中，<code>setState</code> 更新队列时，存储的是合并状态（<code>Object.assign</code>）。因此前面设置的键值会被后面设置的键值覆盖，最终只会执行一次更新。</p> <p>另外需要注意的事，同样不能依赖当前的 Props 计算下个状态，因为 Props 一般也是从父组件的 State 中获取，依然无法确定在组件状态更新时的值。</p> <p>由于 Fiber 及合并的问题，官方推荐可以传入函数的形式使用 <code>setState</code> 。使用函数式，可以用于避免 <code>setState</code> 的批量更新的逻辑，传入的函数将会被<strong>顺序调用</strong>。</p> <p>批量更新以生命周期为界：</p> <ul><li>组件挂载前的所有 <code>setState</code> 批量更新</li> <li>组件挂载后到更新前的所有 <code>setState</code> 批量更新</li> <li>每次更新间隙的所有 <code>setState</code> 批量更新</li></ul> <p>⚠️ 注意事项：</p> <ul><li><code>setState</code> 合并，在合成事件和生命周期函数中多次连续调用会被优化为一次；</li> <li>当组件已被销毁，如果再次调用 <code>setState</code>，React 会被报错警告，通常有两种解决办法
<ul><li>将数据挂载在外部，通过 Props 传入，如放到 Redux 或父级中；</li> <li>在组件内部维护一个状态量（isUnmounted），<code>componentWillUnmount</code> 中标记为 <code>true</code>，在 <code>setState</code> 前进行判断；</li> <li>如果是异步请求副作用，可以在 <code>componentWillUnmount</code> 中取消未响应的异步请求。</li></ul></li></ul> <h2 id="最佳实践"><a href="#最佳实践" aria-hidden="true" class="header-anchor">#</a> 最佳实践</h2> <ul><li><a href="#%E7%9B%B8%E5%90%8C%E5%91%A8%E6%9C%9F%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8">相同周期多次调用</a></li> <li><strong>同步更新策略</strong> <ul><li><a href="#%E5%AE%8C%E6%88%90%E5%9B%9E%E8%B0%83">完成回调</a></li> <li><a href="#%E4%BC%A0%E5%85%A5%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0">传入状态计算函数</a></li></ul></li></ul> <h3 id="相同周期多次调用"><a href="#相同周期多次调用" aria-hidden="true" class="header-anchor">#</a> 相同周期多次调用</h3> <p>当相同周期内多次调用 <code>setState()</code> 以更新相同的状态时，这些调用可能会被合并在一起。</p> <p>设想有一个需求，需要在 <code>onClick</code> 里累加两次。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">onClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> index<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>index <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> index<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>index <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>当 React 对代码进行解析时，会对上述代码作以下解析：</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>
	previousState<span class="token punctuation">,</span>
	<span class="token punctuation">{</span>index<span class="token punctuation">:</span> state<span class="token punctuation">.</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">{</span>index<span class="token punctuation">:</span> state<span class="token punctuation">.</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token operator">...</span>
<span class="token punctuation">)</span>
</code></pre></div><p>由于后面的数据会覆盖前面的更改，所以最终只加了一次。所以如果是下一个 State 的更新依赖前一个 State 的情况下，推荐 <code>setState()</code> 的 <code>updater</code> 参数使用函数形式传入。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">onClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevState<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> quantity<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>quantity <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevState<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> quantity<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>quantity <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="同步更新策略"><a href="#同步更新策略" aria-hidden="true" class="header-anchor">#</a> 同步更新策略</h3> <p>由于 <code>setState</code> 采取异步批量更新策略，而实际业务中某些场景需要用到同步更新逻辑。</p> <p>🌰 案例：从服务端请求数据并且渲染到页面后，隐藏加载进度条或者外部加载提示 <a href="https://zhuanlan.zhihu.com/p/24781259" target="_blank" rel="noopener noreferrer">原文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://example.com'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> something <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        StatusBar<span class="token punctuation">.</span><span class="token function">setNetworkActivityIndicatorVisible</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为 <code>setState</code> 函数并<strong>不会阻塞</strong>等待状态更新完毕，因此 <code>setNetworkActivityIndicatorVisible</code> 有可能先于数据渲染完毕就执行。我们可以选择在 <code>componentWillUpdate</code> 与 <code>componentDidUpdate</code> 这两个生命周期的回调函数中执行 <code>setNetworkActivityIndicatorVisible</code>，但是会让代码变得破碎，可读性也不好。</p> <p>实际上在项目开发中我们更频繁遇见此类问题的场景是通过某个变量控制元素可见性：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  showForm<span class="token punctuation">:</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>showForm<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们预期的效果是每次事件触发后改变表单的可见性，但是在大型应用程序中如果事件的触发速度快于 <code>setState</code> 的更新速度，那么我们的值计算完全就是错的。本节就是讨论两种方式来保证 <code>setState</code> 的同步更新。</p> <h4 id="完成回调"><a href="#完成回调" aria-hidden="true" class="header-anchor">#</a> 完成回调</h4> <p><code>setState</code> 函数的第二个参数允许传入回调函数，<strong>在状态更新完毕后进行调用</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>
  <span class="token punctuation">{</span>
    load<span class="token punctuation">:</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>load<span class="token punctuation">,</span>
    count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'加载完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里回调函数用法相信大家很熟悉，就是 JavaScript 异步编程相关知识，我们可以引用 Promise 来封装 setState：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setStateAsync</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>setStateAsync 返回的是 Promise 对象，在调用时我们可以使用 Async/Await 语法来优化代码风格：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    StatusBar<span class="token punctuation">.</span><span class="token function">setNetworkActivityIndicatorVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://api.ipify.org?format=json'</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>ip<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setStateAsync</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ipAddress<span class="token punctuation">:</span> ip<span class="token punctuation">}</span><span class="token punctuation">)</span>
    StatusBar<span class="token punctuation">.</span><span class="token function">setNetworkActivityIndicatorVisible</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们就可以保证在 setState 渲染完毕之后调用外部状态栏将网络请求状态修改为已结束，整个组件的完整定义为：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">AwesomeProject</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">setStateAsync</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">async</span> <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token operator">...</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">View</span></span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>styles<span class="token punctuation">.</span>container<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span></span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>styles<span class="token punctuation">.</span>welcome<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
          My IP is </span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>ipAddress <span class="token operator">||</span> <span class="token string">'Unknown'</span><span class="token punctuation">}</span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Text</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">View</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="传入状态计算函数"><a href="#传入状态计算函数" aria-hidden="true" class="header-anchor">#</a> 传入状态计算函数</h4> <p>除了使用回调函数的方式监听状态更新结果之外，React 还允许我们传入某个状态计算函数而不是对象来作为第一个参数。状态计算函数能够为我们提供可信赖的组件的 State 与 Props 值，即会自动地将我们的状态更新操作添加到队列中并等待前面的更新完毕后传入最新的状态值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">prevState<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    showForm<span class="token punctuation">:</span> <span class="token operator">!</span>prevState<span class="token punctuation">.</span>showForm<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="浏览器监听事件"><a href="#浏览器监听事件" aria-hidden="true" class="header-anchor">#</a> 浏览器监听事件</h3> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      value<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      index<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第1次输出 0</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第2次输出 0</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第3次输出 2</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第4次输出 3</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>index <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>button<span class="token punctuation">&quot;</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>setTimeout</code> 里的两次 <code>setState</code> 的值同步更新了，</p> <p>在 React 中，如果是由 React 引发的事件处理（比如：onClick 引发的事件处理），调用 setState 不会同步更新 <code>this.state</code>，除此之外的 setState 调用会同步执行 <code>this.setState</code>。&quot;除此之外&quot;指的是：绕过 React 通过 addEventListener 直接添加的事件处理函数和 <code>setTimeout/setInterval</code> 产生的异步调用。</p> <h2 id="实现流程"><a href="#实现流程" aria-hidden="true" class="header-anchor">#</a> 实现流程</h2> <p>setState 流程还是很复杂的，设计也很精巧，避免了重复无谓的刷新组件。它的主要流程如下</p> <ol><li>enqueueSetState 将 state 放入队列中，并调用 enqueueUpdate 处理要更新的 Component</li> <li>如果组件当前正处于 update 事务中，则先将 Component 存入 dirtyComponent 中。否则调用 batchedUpdates 处理。</li> <li>batchedUpdates 发起一次 transaction.perform()事务</li> <li>开始执行事务初始化，运行，结束三个阶段
<ul><li>初始化：事务初始化阶段没有注册方法，故无方法要执行</li> <li>运行：执行 setSate 时传入的 callback 方法，一般不会传 callback 参数</li> <li>结束：更新 isBatchingUpdates 为 false，并执行 FLUSH_BATCHED_UPDATES 这个 wrapper 中的 close 方法</li></ul></li> <li>FLUSH_BATCHED_UPDATES 在 close 阶段，会循环遍历所有的 dirtyComponents，调用 updateComponent 刷新组件，并执行它的 pendingCallbacks, 也就是 setState 中设置的 callback。</li></ol> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <ul><li>setState 不会立即更改 React 组件内状态</li> <li>setState 通过引发一次组件的更新过程来引发重新渲染
<ul><li>shouldComponentUpdate（被调用时，<code>this.state</code> 没有更新；如果返回 <code>false</code>，生命周期中断，但 <code>this.state</code> 仍会更新）</li> <li>componentWillUpdate（被调用时 <code>this.state</code> 没有更新）</li> <li>render（被调用时 <code>this.setState</code> 得到更新）</li> <li>componentDidUpdate</li></ul></li> <li>setState 的多次调用产生的效果将被合并</li></ul> <hr> <p><strong>引用参考：</strong></p> <ul><li><a href="https://juejin.im/post/5a155f906fb9a045284622b4" target="_blank" rel="noopener noreferrer">【React】setState 详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5b87d14e6fb9a01a18268caf" target="_blank" rel="noopener noreferrer">揭秘 React setState<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://zhuanlan.zhihu.com/p/24781259" target="_blank" rel="noopener noreferrer">React 中 setState 的同步更新策略<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.jianshu.com/p/7d2f9e582403" target="_blank" rel="noopener noreferrer">从 setState Promise 化的探讨体会 React 团队设计思想<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5b45d406f265da0f8e19d4c8?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com" target="_blank" rel="noopener noreferrer">React 的生命周期与 setState 的关系<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://overreacted.io/how-does-setstate-know-what-to-do/" target="_blank" rel="noopener noreferrer">How Does setState Know What to Do?<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/react-guidebook/core/diffing-algorithm.html" class="prev">
          差异化算法
        </a></span> <span class="next"><a href="/react-guidebook/mechanism/render.html">
          渲染策略
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/react-guidebook/assets/js/app.260c1e95.js" defer></script><script src="/react-guidebook/assets/js/2.faf5b053.js" defer></script><script src="/react-guidebook/assets/js/12.96017118.js" defer></script>
  </body>
</html>
